{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red131\green108\blue40;
\red63\green110\blue116;}
{\*\expandedcolortbl;;\csgenericrgb\c0\c0\c0;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c51200\c42300\c15700;
\csgenericrgb\c24700\c43100\c45600;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \cb3 Introduzione\
\cf0 \
\cf2 Lo sviluppo di applicazioni web su Internet, ma non solo, richiede di scambiare dati fra applicazioni eterogenee, ad esempio tra un client web scritto in Javascript e un server, e viceversa. Uno standard per lo scambio di dati molto diffuso \'e8    lo standard JavaScript Object Notation, o JSON. Lo scopo di questo progetto \'e8 di realizzare due librerie, una in Prolog e l\'92altra in Common Lisp, che costruiscano delle strutture dati che rappresentino degli oggetti JSON a partire dalla loro rappresentazione come stringhe.\cf0 \
\
\cf2 La sintassi delle stringhe JSON\cf0 \
\cf4 -\cf2  JSON ::= Object | Array\cf0 \
\cf4 -\cf2  Object ::= '\{\}' | '\{' Members '\}'\cf0 \
\cf4 -\cf2  Members ::= Pair | Pair ',' Members\cf0 \
\cf4 -\cf2  Pair ::= String ':' Value\cf0 \
\cf4 -\cf2  Array ::= '[]' | '[' Elements ']'\cf0 \
\cf4 -\cf2  Elements ::= Value | Value ',' Elements\cf0 \
\cf4 -\cf2  Value ::= JSON | Number | String\cf0 \
\cf4 -\cf2  Number ::= Digit+ | Digit+ '.' Digit+ Digit  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\cf0 \
\cf4 -\cf2  String ::= '"' AnyCharSansDQ* '"' | '\'92' AnyCharSansSQ* '\'92'\cf0 \
\cf4 -\cf2  AnyCharSansDQ ::= <qualunque carattere (ASCII) diverso da '"'>\cf0 \
\cf4 -\cf2  AnyCharSansSQ ::= <qualunque carattere (ASCII) diverso da '\'92'>\cf0 \
\
\cf2 Dalla    grammatica    data,    un    oggetto    JSON    pu\'f2    essere    scomposto    ricorsivamente    nelle    seguenti    parti:\cf0 \
\cf4 1.\cf2  Object\cf0 \
\cf4 2.\cf2  Pair\cf0 \
\cf4 3.\cf2  Array\cf0 \
\cf4 4.\cf2  Value\cf0 \
\cf4 5.\cf2  String\cf0 \
\cf4 6.\cf2  Number\cf0 \
\
\cf2 Esempi\cf0 \
\cf2 L'oggetto vuoto:\cf0 \
\cf5 \{\}\cf0 \
\cf2 L'array vuoto:\cf0 \
\cf5 []\cf0 \
\cf2 Un oggetto con due "items":\cf0 \
\cf5 \{"nome": "Arthur", "cognome": 'Dent'\}\cf0 \
\cf2 Un oggetto complesso, contenente un sotto-oggetto, che a sua volta contiene un array di numeri (notare che, in generale, gli array non devono necessariamente avere tutti gli    elementi dello stesso tipo)\cf0 \
\cf5 \{\cf0 \
\cf5 	"modello": "SuperBook 1234",\cf0 \
\cf5 	"anno di produzione": 2014,\cf0 \
\cf5 	"processore":\cf0 \
\cf5 		\{\cf0 \
\cf5 			"produttore": "EsseTi",\cf0 \
\cf5 			"velocit\'e0 di funzionamento (GHz)": [1, 2, 4, 8]\cf0 \
\cf5 		\}\cf0 \
\cf5 \}\cf0 \
\cf2 Un altro esempio tratto da Wikipedia (una possibile voce di menu)\cf0 \
\cf5 \{\cf0 \
\cf5 	"type": "menu",\cf0 \
\cf5 	"value": "File",\cf0 \
\cf5 	"items":\cf0 \
\cf5 		[\cf0 \
\cf5 			\{"value": "New", "action": "CreateNewDoc"\},\cf0 \
\cf5 			\{"value": "Open", "action": "OpenDoc"\},\cf0 \
\cf5 			\{"value": "Close", "action": "CloseDoc"\}\cf0 \
\cf5 		]\cf0 \
\cf5 \}\cf0 \
\
\
\cf2 Realizzazione Prolog\cf0 \
\cf2 La realizzazione in Prolog del parser richiede la definizione di due predicati: \cf4 `\cf5 json_parse/2\cf4 `\cf2  e \cf4 `\cf5 json_get/3\cf4 `\cf2 .\cf0 \
\cf2 Il predicato \cf4 `\cf5 json_parse/2\cf4 `\cf2  \'e8 definibile come: \cf4 `\cf5 json_parse(JSONString, Object)\cf4 `\cf2 .\cf0 \
\cf2 che risulta vero se JSONString (una stringa SWI Prolog o un atomo Prolog) pu\'f2 venire scorporata come stringa, numero, o nei termini composti:\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Object = json_obj(Members)\cf4 `\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Object = json_array(Elements)\cf4 `\cf0 \
\
\cf2 e ricorsivamente:\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Members = []\cf4 `\cf2  or\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Members = [Pair | MoreMembers]\cf4 `\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Pair = (Attribute, Value)\cf4 `\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Attribute = <string SWI Prolog>\cf4 `\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Number = <numero Prolog>\cf4 `\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Value = <string SWI     Prolog> | Number | Object\cf4 `\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Elements = []\cf4 `\cf2  or\cf0 \
\cf4 -\cf2  \cf4 `\cf5 Elements = [Value | More elements]\cf4 `\cf0 \
\
\cf2 Il predicato json_get/3 \'e8 definibile come: \cf4 `\cf5 json_get(JSON_obj, Fields, Result)\cf4 `\cf2 . che risulta vero quando \cf4 `\cf5 Result\cf4 `\cf2  \'e8 recuperabile seguendo la catena di campi presenti in \cf4 `\cf5 Fields\cf4 `\cf2  (una lista) a partire da \cf4 `\cf5 JSON_obj\cf4 `\cf2 . Un campo rappresentato da \cf4 `\cf5 N\cf4 `\cf2  (con \cf4 `\cf5 N\cf4 `\cf2  un numero maggiore o uguale a 0) corrisponde a un indice di un array JSON.\cf0 \
\cf2 Come caso speciale dovete anche gestire il caso \cf4 `\cf5 json_get(JSON_obj, Field, Result).\cf4 `\cf2  Dove \cf4 `\cf5 Field\cf4 `\cf2  \'e8 una stringa SWI Prolog.\cf0 \
\
\cf2 La libreria fornisce due predicati per la lettura da file e la scrittura su file.\cf0 \
\cf4 -\cf2  \cf4 `\cf5 json_load(FileName, JSON).\cf4 `\cf0 \
\cf4 -\cf2  \cf4 `\cf5 json_write(JSON, FileName).\cf4 `\cf0 \
\
\cf2 Il predicato \cf4 `\cf5 json_load/2\cf4 `\cf2  apre il file FileName e ha successo se riesce a costruire un oggetto JSON. Se FileName non esiste il predicato fallisce. Il suggerimento \'e8 di leggere l'intero file in una stringa e poi di richiamare \cf4 `\cf5 json_parse/2\cf4 `\cf2 . Il predicato \cf4 `\cf5 json_write/2\cf4 `\cf2  scrive l'oggetto JSON sul file FileName in sintassi JSON.  Se FileName non esiste, viene creato e se esiste viene sovrascritto.  }