{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red27\green31\blue34;\red10\green77\blue204;\red244\green246\blue249;
\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c14118\c16078\c18039;\cssrgb\c1176\c40000\c83922;\cssrgb\c96471\c97255\c98039;
\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl440\sa320\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
Introduzione\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 Lo sviluppo di applicazioni web su Internet, ma non solo, richiede di scambiare dati fra applicazioni eterogenee, ad esempio tra un client web scritto in Javascript e un server, e viceversa. Uno standard per lo scambio di dati molto diffuso \'e8 lo standard JavaScript Object Notation, o JSON. Lo scopo di questo progetto \'e8 di realizzare due librerie, una in Prolog e l\'92altra in Common Lisp, che costruiscano delle strutture dati che rappresentino degli oggetti JSON a partire dalla loro rappresentazione come stringhe.\
\pard\pardeftab720\sl440\sa320\partightenfactor0
\cf2 La sintassi delle stringhe JSON\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
JSON ::= Object | Array\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Object ::= '\{\}' | '\{' Members '\}'\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Members ::= Pair | Pair ',' Members\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Pair ::= String ':' Value\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Array ::= '[]' | '[' Elements ']'\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Elements ::= Value | Value ',' Elements\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Value ::= JSON | Number | String\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Number ::= Digit+ | Digit+ '.' Digit+ Digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
String ::= '"' AnyCharSansDQ* '"' | '\'92' AnyCharSansSQ* '\'92'\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
AnyCharSansDQ ::= <qualunque carattere (ASCII) diverso da '"'>\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
AnyCharSansSQ ::= <qualunque carattere (ASCII) diverso da '\'92'>\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 Dalla grammatica data, un oggetto JSON pu\'f2 essere scomposto ricorsivamente nelle seguenti parti:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Object\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Pair\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
Array\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
Value\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	5.	}\expnd0\expndtw0\kerning0
String\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	6.	}\expnd0\expndtw0\kerning0
Number\
\pard\pardeftab720\sl360\partightenfactor0
\cf3 \
\pard\pardeftab720\sl440\sa320\partightenfactor0
\cf2 Esempi\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 L'oggetto vuoto:\
\pard\pardeftab720\sl380\partightenfactor0
\cf2 \cb4 \{\}\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 \cb1 L'array vuoto:\
\pard\pardeftab720\sl380\partightenfactor0
\cf2 \cb4 []\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 \cb1 Un oggetto con due "items":\
\pard\pardeftab720\sl380\partightenfactor0
\cf2 \cb4 \{"nome": "Arthur", "cognome": 'Dent'\}\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 \cb1 Un oggetto complesso, contenente un sotto-oggetto, che a sua volta contiene un array di numeri (notare che, in generale, gli array non devono necessariamente avere tutti gli elementi dello stesso tipo)\
\pard\pardeftab720\sl380\partightenfactor0
\cf2 \cb4 \{\
	"modello": "SuperBook 1234",\
	"anno di produzione": 2014,\
	"processore":\
		\{\
		"produttore": "EsseTi",\
		"velocit\'e0 di funzionamento (GHz)": [1, 2, 4, 8]\
		\}\
\}\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 \cb1 Un altro esempio tratto da Wikipedia (una possibile voce di menu)\
\pard\pardeftab720\sl380\partightenfactor0
\cf2 \cb4 \{\
	"type": "menu",\
	"value": "File",\
	"items":\
	[\
		\{"value": "New", "action": "CreateNewDoc"\},\
		\{"value": "Open", "action": "OpenDoc"\},\
		\{"value": "Close", "action": "CloseDoc"\}\
	]\
\}\
\pard\pardeftab720\sl360\partightenfactor0
\cf3 \cb1 \
\pard\pardeftab720\sl280\partightenfactor0
\cf5 Realizzazione Common Lisp \
La realizzazione Common Lisp deve fornire due funzioni. U\
na funzione json-parse che accetta in ingresso una stringa e produce una struttura simile a quella illustrata per la realizzazione Prolog, una funzione json-get che accetta un oggetto JSON (rappresentato in Common Lisp, cos\'ec come prodotto dalla funzione json_parse) e una serie di \'93campi\'94, recupera l\'92oggetto corrispondente. Un campo rappresentato da N (con N un numero maggiore o uguale a 0) rappresenta un indice di un array JSON. \
\
La sintassi degli oggetti JSON in Common Lisp \'e8: \
Object = \'92(\'92 json-obj members \'92)\'92 \
Object = \'92(\'92 json-array elements \'92)\'92 e ricorsivamente: \
members = pair* \
pair = \'92(\'92 attribute value \'92)\'92 \
attribute = <atomo Common Lisp> | <stringa Common Lisp>\
number = <numero Common Lisp>\
value = string | number | Object \
elements = value*\
\
L\'92idea di base per la realizzazione del parser \'e8 la divisione ricorsiva dell\'92oggetto JSON in pi\'f9 parti e il passaggio di attributi/oggetti/array alle rispettive funzioni per il controllo della validit\'e0 della sintassi e la trasformazione delle coppie attribute-value in cons cells, e dell\'92array in una lista. Sono state introdotte alcune funzioni ausiliarie per il controllo, il parsing dei valori, l\'92invertibilit\'e0 dell\'92oggetto parsato. \
La funzione json-get ha un campo (opzionale) e una lista di campi utile per fare i controlli e scendere in profondit\'e0. Si appoggia a search-array che effettua una ricerca in base all\'92indice dell\'92array.\
I singoli caratteri vengono ricompattati in stringhe in base ai doppi apici, e i numeri vengono convertiti dalle stringhe usando parse-integer pi\'f9 qualche funzione aggiuntiva per convertire i numeri in floating point e negativi.\
\
Le principali funzioni utilizzate in Common Lisp sono:\
JSON-PARSE controlla se l\'92argomento \'e8 una stringa, trasforma la stringa in lista, chiama CLEAN-CHARLIST che rimuove spazi, tab e invii e poi passa il risultato a JSON-PARSE-CHARLIST.\
JSON-PARSE-CHARLIST controlla che le parentesi siano bilanciate e a seconda che siano graffe o quadre chiama l\'92opportuna funzione sui valori all\'92interno delle parentesi.\
PARSE-MEMBERS usando degli accumulatori e dei contatori per il bilanciamento degli apici, divide le coppie attributo-valore che poi saranno controllate singolarmente da PARSE-VALUE.\
PARSE-ARRAY controlla che i valori dell\'92array siano stringhe, numeri oppure oggetti JSON sempre tramite PARSE-VALUE.\
JSON-GET che restituisce il valore ottenuto seguendo una sequenza ordinata di stringhe, e l\'92equivalente per array SEARCH-ARRAY.\
REVERT-OBJ e REVERT-ARRAY per trasformare da sintassi Common Lisp a JSON, costruisce ricorsivamente una stringa (tramite concatenate) usando un accumulatore e la restituisce nel caso base.\
JSON-LOAD e JSON-WRITE per l\'92I/O da file.\
}